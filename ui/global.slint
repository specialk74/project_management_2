import {
    Button,
    VerticalBox,
    ListView,
    CheckBox,
    LineEdit,
    Spinner,
    TextEdit,
    HorizontalBox,
    ProgressIndicator,
    StyleMetrics,
    Palette,
} from "std-widgets.slint";

import { Styles } from "styles.slint";

export global AppState {
    in property <[{title: string, col: color, text-color: color}]> model: [
        { title: "Mcsw", col: #0099ff, text-color: Colors.white },
        { title: "Sms", col: Colors.violet, text-color: Colors.black },
        { title: "Mvh", col: Colors.brown, text-color: Colors.white },
        { title: "Hw", col: Colors.green, text-color: Colors.black },
        { title: "Ele", col: Colors.blue, text-color: Colors.white },
        { title: "Hw Test", col: Colors.yellow, text-color: Colors.black },
        { title: "Fw Test", col: Colors.purple, text-color: Colors.white },
        { title: "Sys Test", col: Colors.orange, text-color: Colors.black },
        { title: "Pjm", col: Colors.cyan, text-color: Colors.black }
    ];

    in property <[string]> worker_names: [
        "Alice",
        "Bob",
        "Charlie",
        "David",
        "Eve",
        "Frank",
        "Grace",
        "Heidi",
        "Ivan",
        "Judy",
        "Andrea"
    ];
}

export struct EffortByDateData {
    total: int,
    remains: int,
    dev: int,
    project: int,
    effort: int,
    date: int,
    persons: [string],
}

export struct EffortByDevData {
    project: int,
    dev: int,
    total: int,
    effort: int,
    remains: int,
    visible: bool,
    max: int,
    datas: [EffortByDateData],
}

export struct EffortByPrjData {
    project: int,
    text: string,
    start: int,
    visible: bool,
    efforts: [EffortByDevData]
}

export struct EffortsData {
    today: int,
    projects: [EffortByPrjData]
}

export global PjmCallback {
    callback changed_effort(EffortByDateData);
    callback set_dev_effort(EffortByDevData);
    callback save_file();
    callback search(string);
    callback new_project();
    callback add_row(int, int);
    in property <string> testo-copiato;
    in property <string> last-search;
    in property <bool> show_modal;
    in property <bool> changed;
}

component InternalText inherits Text {
    overflow: clip;
    vertical-alignment: center;
    horizontal-alignment: center;
    wrap: word-wrap;
}

export component Cell-RO inherits Rectangle {
    in property <string> text;
    in property <color> text_color: Palette.color-scheme == ColorScheme.dark ? Colors.white : Colors.black;
    in property <int> font-weight: 800;
    //in property <color> error_color: #ffffff;
    //in property <color> background_color: #ffffff;
    in property <TextHorizontalAlignment> horizontal-alignment: TextHorizontalAlignment.center;

    height: self.visible ? Styles.height : 0px;
    width: Styles.width;
    //background: root.error_color;

    clip: true;
    Rectangle {
        width: parent.width - 5px;
        height: parent.visible ? parent.height - 5px : 0px;

        innerRect := Rectangle {
            property <length> parent_width: parent.width;
            property <length> position: (parent.width - self.width) / 2;
            property <length> start_position: (parent.width - self.width) / 2;
            property <bool> running: self.width > parent.width;
            x: position;
            width: myText.width;
            animate x {
                duration: 1000ms;
                easing: ease-in-out;
            }
            Timer {
                interval: 5000ms;
                running: running;

                triggered => {
                    position = position == 0 ? (parent_width - innerRect.width) : 0;
                }
            }

            myText := InternalText {
                color: root.text_color;
                text: root.text;
                font-weight: root.font-weight;
                horizontal-alignment: root.horizontal-alignment;
            }
        }
    }
}

export component Cell-RW inherits Rectangle {
    in-out property <string> text;
    callback double_clicked(string);
    property <bool> editing: false;
    height: self.visible ? Styles.height : 0px;
    width: Styles.width;

    fs := FocusScope {
        focus-on-click: true;
        focus-on-tab-navigation: true;
        le := LineEdit {
            visible: editing;
            height: 100%;
            width: 100%;
            text <=> root.text;
            accepted => {
                root.double_clicked(root.text);
                root.editing = false;
                fs.focus();
            }
        }

        Rectangle {
            visible: !editing;
            border-color: fs.has-focus ? Colors.yellow : Colors.transparent;
            border-width: parent.visible ? 1px : 0px;
            TouchArea {
                double-clicked => {
                    root.editing = true;
                    le.focus();
                }
                clicked => {
                    fs.focus();
                }
            }

            Cell-RO {
                text: root.text;
            }
        }

        key-pressed(event) => {
            if (event.modifiers.control) {
                if (event.text == "C" || event.text == "c") {
                    PjmCallback.testo-copiato = root.text;
                }
                if (event.text == "V" || event.text == "v") {
                    root.text = PjmCallback.testo-copiato;
                    root.double_clicked(root.text);
                }
                if (event.text == "S" || event.text == "s") {
                    PjmCallback.save_file();
                }
                if (event.text == "f") {
                    PjmCallback.show_modal = true;
                    //im.focus();
                    //im.select-all();
                    return accept;
                }
                if (event.text == "F") {
                    PjmCallback.last-search = "";
                    PjmCallback.search("");
                    return accept;
                }
            }
            if (event.text == Key.Escape) {
                root.editing = false;
                le.clear-focus();
                fs.focus();
            }
            if (event.text == Key.Return) {
                root.editing = true;
                le.focus();
            }
            if (event.text == Key.Tab) {
                reject
            } else {
                accept
            }
        }
    }
}

export component EffortByDataGui inherits Rectangle {
    in property <int> num_visible;
    in property <EffortByDateData> effort;

    popup := Rectangle {
        x: cell.x;
        y: cell.y + Styles.height;
        visible: t.has-hover;
        height: Styles.height;
        width: Styles.width;
        background: yellow;
        Text {
            font-weight: 800;
            text: effort.remains;
            color: Colors.black;
        }
    }

    VerticalLayout {
        spacing: 0px;
        padding: 0px;

        function my-function(effort: EffortByDateData) -> color {
            if effort.total == 0 {
                return Palette.color-scheme == ColorScheme.dark ? Colors.white : Colors.black;
            }
            if effort.total < effort.effort * 10 / 100 {
                return #6fff00;
            }
            if effort.total < effort.effort * 20 / 100 {
                return #99ff00;
            }
            if effort.total < effort.effort * 30 / 100 {
                return #ccff00;
            }
            if effort.total < effort.effort * 40 / 100 {
                return #ffff00;
            }
            if effort.total < effort.effort * 50 / 100 {
                return #ffcc00;
            }
            if effort.total < effort.effort * 60 / 100 {
                return #ffaa00;
            }
            if effort.total < effort.effort * 70 / 100 {
                return #ff8800;
            }
            if effort.total < effort.effort * 80 / 100 {
                return #ff5500;
            }
            if effort.total < effort.effort * 90 / 100 {
                return #ff3300;
            }
            return #ff0000;
        }

        cell := Cell-RO {
            visible: root.visible;
            text: effort.total;
            text_color: my-function(effort);

            t := TouchArea {
                width: parent.width;
                height: parent.height;
            }
        }

        for person in effort.persons: Cell-RW {
            text: person;
            visible: root.visible;

            double_clicked(text) => {
                person = text;
                PjmCallback.changed_effort(root.effort)
            }
        }
    }
}

export component EffortByDevGui inherits Rectangle {
    in property <int> num_visible;
    in property <EffortByDevData> datas;
    in property <int> index;
    visible: datas.visible;
    VerticalLayout {
        Rectangle {
            height: datas.visible ? 5px : 0px;
            background: AppState.model[root.index].col;
        }

        HorizontalBox {
            spacing: 0px;
            padding: 0px;

            for data in datas.datas: EffortByDataGui {
                num_visible: root.num_visible;
                effort: data;
                visible: datas.visible;
            }
        }

        Rectangle {
            height: datas.visible ? 5px : 0px;
            background: AppState.model[root.index].col;
        }
    }
}

export component EffortByPrjGui inherits Rectangle {
    in property <int> num_visible;
    in property <EffortByPrjData> effort;
    visible: effort.visible;
    VerticalLayout {
        spacing: 0px;
        padding: 0px;

        for data[index] in effort.efforts: EffortByDevGui {
            index: index;
            num_visible: root.num_visible;
            datas: data;
        }
        Rectangle {
            height: 5px;
            background: Colors.cyan;
        }
    }
}
